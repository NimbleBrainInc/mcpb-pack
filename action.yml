name: "MCPB Pack"
description: "Package MCP servers into .mcpb bundles, upload to releases, and announce to registry"
author: "NimbleBrain Inc"

branding:
  icon: "package"
  color: "blue"

inputs:
  directory:
    description: "Directory containing the MCP server and manifest.json"
    required: false
    default: "."
  output:
    description: "Output filename for the .mcpb bundle (supports {name}, {version} placeholders)"
    required: false
  python-version:
    description: "Python version for vendoring deps (if Python server)"
    required: false
    default: "3.13"
  build:
    description: "Whether to build the .mcpb bundle"
    required: false
    default: "true"
  upload:
    description: "Whether to upload the bundle to the GitHub release (requires release event)"
    required: false
    default: "true"
  announce:
    description: "Whether to announce the bundle to the registry"
    required: false
    default: "true"
  announce-url:
    description: "URL of the mpak registry announce endpoint"
    required: false
    default: "https://api.mpak.dev/v1/bundles/announce"

outputs:
  bundle-path:
    description: "Path to the generated .mcpb file"
    value: ${{ steps.pack.outputs.path }}
  bundle-size:
    description: "Size of the bundle in bytes"
    value: ${{ steps.pack.outputs.size }}
  bundle-sha256:
    description: "SHA256 hash of the bundle for integrity verification"
    value: ${{ steps.pack.outputs.sha256 }}
  announced:
    description: "Whether the bundle was announced successfully"
    value: ${{ steps.announce.outputs.announced }}

runs:
  using: "composite"
  steps:
    - name: Setup Node.js
      if: inputs.build == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: "22"

    - name: Setup Python
      if: inputs.build == 'true'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ inputs.python-version }}

    - name: Install uv
      if: inputs.build == 'true'
      uses: astral-sh/setup-uv@v4

    - name: Install mcpb CLI
      if: inputs.build == 'true'
      shell: bash
      run: npm install -g @anthropic-ai/mcpb

    - name: Vendor dependencies
      if: inputs.build == 'true'
      shell: bash
      run: |
        cd "${{ inputs.directory }}"

        # Detect runtime from manifest
        RUNTIME=$(jq -r '.server.type // .server.runtime // "unknown"' manifest.json)
        echo "Detected runtime: $RUNTIME"

        if [ "$RUNTIME" = "python" ]; then
          echo "Vendoring Python dependencies..."
          rm -rf deps/
          uv pip install --target ./deps --only-binary :all: . 2>/dev/null || \
          uv pip install --target ./deps .

          # Show what was installed (use || true to avoid SIGPIPE errors)
          echo "Vendored packages:"
          ls deps/ | head -20 || true
          du -sh deps/
        elif [ "$RUNTIME" = "node" ]; then
          echo "Vendoring Node.js dependencies..."
          rm -rf node_modules/
          npm install --omit=dev --prefix .

          echo "Vendored packages:"
          du -sh node_modules/
        else
          echo "Unknown runtime: $RUNTIME, skipping dependency vendoring"
        fi

    - name: Pack bundle
      id: pack
      if: inputs.build == 'true'
      shell: bash
      run: |
        cd "${{ inputs.directory }}"

        # Read manifest for placeholders
        NAME=$(jq -r '.name // "extension"' manifest.json | sed 's/@//g' | sed 's/\//-/g')
        VERSION=$(jq -r '.version // "0.0.0"' manifest.json)

        if [ -n "${{ inputs.output }}" ]; then
          OUTPUT="${{ inputs.output }}"
          # Replace placeholders
          OUTPUT="${OUTPUT//\{name\}/$NAME}"
          OUTPUT="${OUTPUT//\{version\}/$VERSION}"
        else
          OUTPUT="${NAME}-${VERSION}.mcpb"
        fi

        mcpb pack . "$OUTPUT"

        SIZE=$(stat -f%z "$OUTPUT" 2>/dev/null || stat -c%s "$OUTPUT")
        SHA256=$(shasum -a 256 "$OUTPUT" 2>/dev/null || sha256sum "$OUTPUT" | cut -d' ' -f1)
        SHA256=$(echo "$SHA256" | cut -d' ' -f1)

        echo "path=$OUTPUT" >> $GITHUB_OUTPUT
        echo "size=$SIZE" >> $GITHUB_OUTPUT
        echo "sha256=$SHA256" >> $GITHUB_OUTPUT
        echo "Bundle: $OUTPUT ($(du -h "$OUTPUT" | cut -f1))"
        echo "SHA256: $SHA256"

    - name: Upload to release
      id: upload
      if: inputs.upload == 'true' && inputs.build == 'true' && github.event_name == 'release'
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        cd "${{ inputs.directory }}"
        BUNDLE_PATH="${{ steps.pack.outputs.path }}"
        TAG="${{ github.event.release.tag_name }}"

        echo "Uploading $BUNDLE_PATH to release $TAG"
        gh release upload "$TAG" "$BUNDLE_PATH" --clobber

        echo "uploaded=true" >> $GITHUB_OUTPUT

    - name: Get OIDC Token
      id: oidc
      if: inputs.announce == 'true'
      shell: bash
      run: |
        TOKEN=$(curl -sS -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
          "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=https://www.mpak.dev" | jq -r '.value')

        if [ "$TOKEN" = "null" ] || [ -z "$TOKEN" ]; then
          echo "::error::Failed to get OIDC token. Ensure 'permissions: id-token: write' is set."
          exit 1
        fi

        echo "::add-mask::$TOKEN"
        echo "token=$TOKEN" >> $GITHUB_OUTPUT

    - name: Announce bundle
      id: announce
      if: inputs.announce == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
        OIDC_TOKEN: ${{ steps.oidc.outputs.token }}
        BUNDLE_PATH: ${{ steps.pack.outputs.path }}
        BUNDLE_SIZE: ${{ steps.pack.outputs.size }}
        BUNDLE_SHA256: ${{ steps.pack.outputs.sha256 }}
      run: |
        cd "${{ inputs.directory }}"

        # Read manifest
        NAME=$(jq -r '.name // "unknown"' manifest.json)
        VERSION=$(jq -r '.version // "unknown"' manifest.json)

        # Detect current platform
        OS_RAW=$(uname -s)
        ARCH_RAW=$(uname -m)

        # Normalize OS
        case "$OS_RAW" in
          Linux)  OS="linux" ;;
          Darwin) OS="darwin" ;;
          *)      OS=$(echo "$OS_RAW" | tr '[:upper:]' '[:lower:]') ;;
        esac

        # Normalize architecture
        case "$ARCH_RAW" in
          x86_64)  ARCH="amd64" ;;
          aarch64) ARCH="arm64" ;;
          arm64)   ARCH="arm64" ;;
          *)       ARCH="$ARCH_RAW" ;;
        esac

        echo "Detected platform: $OS-$ARCH"

        # Get release info from event context or ref
        if [ "${{ github.event_name }}" = "release" ]; then
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          PRERELEASE="${{ github.event.release.prerelease }}"
        else
          RELEASE_TAG="${{ github.ref_name }}"
          # Detect prerelease from version string (alpha, beta, rc, etc.)
          if [[ "$VERSION" =~ (alpha|beta|rc|pre|dev) ]]; then
            PRERELEASE="true"
          else
            PRERELEASE="false"
          fi
        fi

        # Build announce payload with artifact info (idempotent per-artifact)
        PAYLOAD=$(jq -n \
          --arg name "$NAME" \
          --arg version "$VERSION" \
          --slurpfile manifest manifest.json \
          --arg release_tag "$RELEASE_TAG" \
          --argjson prerelease "$PRERELEASE" \
          --arg filename "$BUNDLE_PATH" \
          --arg os "$OS" \
          --arg arch "$ARCH" \
          --arg sha256 "$BUNDLE_SHA256" \
          --argjson size "${BUNDLE_SIZE:-0}" \
          '{
            name: $name,
            version: $version,
            manifest: $manifest[0],
            release_tag: $release_tag,
            prerelease: $prerelease,
            artifact: {
              filename: $filename,
              os: $os,
              arch: $arch,
              sha256: $sha256,
              size: $size
            }
          }')

        echo "Announcing $NAME v$VERSION artifact ($OS-$ARCH) to ${{ inputs.announce-url }}"
        echo "$PAYLOAD" | jq .

        # Retry loop for GitHub API propagation delays
        # After upload, GitHub's API/CDN may take 10-30s to reflect the new asset
        MAX_ATTEMPTS=4
        ATTEMPT=1

        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${{ inputs.announce-url }}" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $OIDC_TOKEN" \
            -d "$PAYLOAD")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')

          echo "HTTP Status: $HTTP_CODE (attempt $ATTEMPT/$MAX_ATTEMPTS)"

          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "announced=true" >> $GITHUB_OUTPUT
            echo "✅ Artifact announced successfully ($OS-$ARCH)"
            echo "$BODY" | jq . 2>/dev/null || echo "$BODY"
            break
          elif echo "$BODY" | grep -q "not found in release" && [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            WAIT=$((ATTEMPT * 5))
            echo "⏳ Artifact not yet visible in GitHub API, retrying in ${WAIT}s... (attempt $ATTEMPT/$MAX_ATTEMPTS)"
            sleep $WAIT
            ATTEMPT=$((ATTEMPT + 1))
          else
            echo "announced=false" >> $GITHUB_OUTPUT
            echo "::error::Failed to announce artifact (HTTP $HTTP_CODE)"
            echo "$BODY" | jq . 2>/dev/null || echo "$BODY"
            exit 1
          fi
        done
